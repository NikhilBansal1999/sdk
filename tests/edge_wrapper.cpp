//******************************************************************************
// Copyright (c) 2018, The Regents of the University of California (Regents).
// All Rights Reserved. See LICENSE for license details.
//------------------------------------------------------------------------------
#include "edge_wrapper.h"
#include "report.h"
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>
#include <error.h>
/* Really all of this file should be autogenerated, that will happen
   eventually. */

#define OCALL_PRINT_BUFFER 1
#define OCALL_PRINT_VALUE 2
#define OCALL_COPY_REPORT 3
#define OCALL_GET_STRING 4
#define OCALL_GET_NUMBER 5
#define OCALL_SET_MEM_PERMS 6
#define GET_PAGE_SIZE 7
#define OCALL_READ_FROM_FILE 8
#define OCALL_RESERVE_PAGE 9


int edge_init(Keystone* enclave){

  enclave->registerOcallDispatch(incoming_call_dispatch);
  register_call(OCALL_PRINT_BUFFER, print_buffer_wrapper);
  register_call(OCALL_PRINT_VALUE, print_value_wrapper);
  register_call(OCALL_COPY_REPORT, copy_report_wrapper);
  register_call(OCALL_GET_STRING, get_host_string_wrapper);
  register_call(OCALL_GET_NUMBER, get_number);
  register_call(OCALL_SET_MEM_PERMS, set_mem_perm);
  register_call(GET_PAGE_SIZE, get_pagesize);
  register_call(OCALL_READ_FROM_FILE, read_from_file_wrapper);
  register_call(OCALL_RESERVE_PAGE, reserve_page);

  edge_call_init_internals((uintptr_t)enclave->getSharedBuffer(),
			   enclave->getSharedBufferSize());
}

unsigned long input_number()
{
  unsigned long ret_val;
  printf("Enter the number:\n");
  scanf("%uld",&ret_val);
  return ret_val;
}

void reserve_page(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;

  uintptr_t call_args;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }

  unsigned long start_vaddr = reserve_memory_from_driver(*(int*)call_args);

  uintptr_t data_section = edge_call_data_ptr();
  memcpy((void*)data_section, &start_vaddr, sizeof(unsigned long));

  if(edge_call_setup_ret(edge_call, (void*)data_section, sizeof(start_vaddr)))
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else
  {
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }
  return;
}

void print_value_wrapper(void* buffer)
{
  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;

  uintptr_t call_args;
  unsigned long ret_val;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }

  print_value(*(long*)call_args);

  edge_call->return_data.call_status = CALL_STATUS_OK;
  return;
}

void copy_report_wrapper(void* buffer)
{

  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;

  uintptr_t data_section;
  unsigned long ret_val;
  //TODO check the other side of this
  if(edge_call_get_ptr_from_offset(edge_call->call_arg_offset, sizeof(report_t),
				   &data_section) != 0) {
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }

  copy_report((void*)data_section);

  edge_call->return_data.call_status = CALL_STATUS_OK;

  return;
}

void get_host_string_wrapper(void* buffer)
{

  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;

  uintptr_t call_args;
  unsigned long ret_val;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }

  const char* host_str = get_host_string();
  size_t host_str_len = strlen(host_str)+1;

  // This handles wrapping the data into an edge_data_t and storing it
  // in the shared region.
  if( edge_call_setup_wrapped_ret(edge_call, (void*)host_str, host_str_len)){
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else{
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }

  return;
}

void read_from_file_wrapper(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  if(edge_call_args_ptr(edge_call,&call_args) != 0)
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  file_struct* file_data = (file_struct*)call_args;

  long block_size = file_data->block_size;
  long num_blocks = file_data->num_blocks;
  long offset = file_data->offset;

  FILE* fd=fopen((char*)(file_data+1),"r");
  if(fd == NULL)
  {
    printf("Error opening file\n");
    return;
  }
  char* data_buf=(char*)malloc(block_size * num_blocks + sizeof(unsigned long));
  if(data_buf == NULL)
  {
    printf("Error allocating buffer\n");
    return;
  }
  if(fseek(fd,offset,SEEK_SET) == -1)
  {
    printf("Error parsing library file\n");
    return;
  }

  int bytes_read=fread(data_buf,block_size,num_blocks,fd);
  uintptr_t data_section = edge_call_data_ptr();
  *((int*)data_section) = bytes_read;
  memcpy((void*)((int*)data_section + 1), (void*)data_buf,bytes_read * block_size);

  if(edge_call_setup_ret(edge_call, (void*)data_section, bytes_read + sizeof(int)))
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else
  {
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }
  return;
}

void get_number(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  if(edge_call_args_ptr(edge_call, &call_args) != 0)
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  unsigned long ret_val = input_number();
  uintptr_t data_section = edge_call_data_ptr();
  memcpy((void*)data_section, &ret_val, sizeof(unsigned long));

  if(edge_call_setup_ret(edge_call, (void*)data_section, sizeof(ret_val)))
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else
  {
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }
  return;
}

void get_pagesize(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  if(edge_call_args_ptr(edge_call, &call_args) != 0)
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  unsigned long ret_val = sysconf(_SC_PAGESIZE);
  uintptr_t data_section = edge_call_data_ptr();
  memcpy((void*)data_section, &ret_val, sizeof(unsigned long));

  if(edge_call_setup_ret(edge_call, (void*)data_section, sizeof(ret_val)))
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else
  {
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }
  return;
}

void set_mem_perm(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  if(edge_call_args_ptr(edge_call,&call_args) != 0)
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }

  mem* memory = (mem*)call_args;

  int ret_val = mprotect(memory->addr,memory->size,memory->prot);
  if(ret_val == 0)
  {
    printf("Mprotect Successful\n");
  }
  else
  {
    printf("Mprotect error %s\n",strerror(errno));
    printf("Error Number %d\n",errno);
  }
  uintptr_t data_section = edge_call_data_ptr();
  memcpy((void*)data_section,&ret_val,sizeof(int));

  if(edge_call_setup_ret(edge_call, (void*)data_section,sizeof(ret_val)))
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else
  {
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }
  return;
}

void print_buffer_wrapper(void* buffer)
{
  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;

  uintptr_t call_args;
  unsigned long ret_val;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }

  ret_val = print_buffer((char*)call_args);

  // We are done with the data section for args, use as return region
  // TODO safety check?
  uintptr_t data_section = edge_call_data_ptr();

  memcpy((void*)data_section, &ret_val, sizeof(unsigned long));

  if( edge_call_setup_ret(edge_call, (void*) data_section, sizeof(unsigned long))){
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else{
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }

  return;

}
